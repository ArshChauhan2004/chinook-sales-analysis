# üéµ Chinook Sales Analysis using SQL

---

## üìñ Overview

This project focuses on exploring and analyzing the Chinook Music Store database using SQL.

The aim is to understand:
- Sales performance
- Revenue distribution
- Genre popularity
- Customer purchasing behavior

The project demonstrates:
- Data exploration
- Aggregation
- Joins
- Analytical SQL techniques (Window Functions)

---

## üéØ Objective

The aim of this project is to:

- Analyze overall sales performance  
- Identify top revenue generating countries  
- Determine revenue contribution by genre  
- Explore track pricing patterns  
- Apply SQL joins for relational analysis  
- Use window functions for ranking analysis  

---

## üìä Dataset

This project uses the **Chinook Music Store Database**, a sample relational database that represents a digital media store.

The database contains information about:

- Artists  
- Tracks  
- Genres  
- Invoices  
- Invoice Lines (Sales details)  
- Customers  

It allows analysis of revenue, genre popularity, and customer purchasing behavior using SQL joins and aggregations.

Dataset Link: [Chinook Music Database Dataset](https://www.kaggle.com/datasets/jacopoferretti/chinook-music-database)

---

## üß† Business Problems and Solutions

Below are the key business questions answered using SQL queries on the Chinook database.

---

### 1Ô∏è. Count Total Number of Artists

```sql
SELECT COUNT(*) AS total_artists
FROM Artist;

```
**Objective:**
- Determine how many artists exist in the database.

---

### 2Ô∏è. Count Total Number of Tracks

```sql
SELECT COUNT(*) AS total_tracks
FROM Track;

```
**Objective:**
- Determine how many tracks are available in the database.

---

### 3Ô∏è. Count Total Number of Genres

```sql
SELECT COUNT(*) AS total_genres
FROM Genre;

```
**Objective:**
- Determine how many music genres exist in the database.

---

### 4Ô∏è. Preview Sample Tracks

```sql
SELECT *
FROM Track
LIMIT 10;

```
**Objective:**
- Quickly preview sample track data to understand table structure and column details.

---

### 5Ô∏è. Number of Tracks per Genre

```sql
SELECT g.Name AS genre_name, COUNT(t.TrackId) AS total_tracks
FROM Genre g
INNER JOIN Track t ON g.GenreId = t.GenreId
GROUP BY g.Name 
ORDER BY total_tracks DESC;

```
**Objective:**
- Determine how many tracks belong to each genre and identify the most popular genres by number of tracks.

---

### 6Ô∏è. Top 5 Most Expensive Tracks

```sql
SELECT Name, UnitPrice
FROM Track
ORDER BY UnitPrice DESC
LIMIT 5;

```
**Objective:**
- Identify the five most expensive tracks in the database and understand pricing distribution at the top end.

---

### 7Ô∏è. Average Track Price

```sql
SELECT ROUND(AVG(UnitPrice),2) AS avg_track_price
FROM Track;

```
**Objective:**
- Calculate the average price of tracks in the database and understand overall pricing level across all tracks.

---

### 8Ô∏è. Total Revenue Generated

```sql
SELECT ROUND(SUM(UnitPrice * Quantity),2) AS total_revenue
FROM InvoiceLine;

```
**Objective:**
- Calculate the total revenue generated from all track sales and understand overall business performance.

---

### 9Ô∏è. Revenue per Genre

```sql
SELECT g.Name AS genre_name,
       ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS revenue
FROM Genre g
INNER JOIN Track t ON g.GenreId = t.GenreId
INNER JOIN InvoiceLine il ON t.TrackId = il.TrackId
GROUP BY g.Name
ORDER BY revenue DESC;

```
**Objective:**
- Calculate total revenue generated by each genre and understand which music categories drive business performance.

---

### 10. Revenue by Country

```sql
SELECT BillingCountry, ROUND(SUM(Total),2) AS total_revenue
FROM Invoice
GROUP BY BillingCountry 
ORDER BY total_revenue DESC;

```
**Objective:**
- Calculate total revenue generated by each country and understand geographic distribution of revenue.

---

